---
layout: post
title: "Why Go?"
date: 2019-06-02 08:00:00 +0200
categories: [coding, programming languages, go]
---
Why and when using Go?
I got my answer from [a talk](https://youtu.be/bmZNaUcwBt4) from Google's Carmen Andoh held at InfoQ 2017.

Here is the gist.

Go was invented at Google from three veteran computer scientists:

- Ken Thompson - the inventor of UNIX
- Robert Griesemer - Java HotSpot, V8
- Rob Pike - Plan 9

The language addresses specific concerns, which might not be everybody's priority when deciding which technology to use for a new project:

1. Concurrency-friendly. Thanks to go-routines, based on green-threads and a sequential model as opposed to the callback model of node.js,
the language runs naturally and efficiently millions of concurrent logical threads, and it's therefore a very good choice for IO-bound massive
scale loads like serving web requests or micro-services. From a hardware/OS standpoint, this is made possible by the introduction of BSD 
kqueue and Linux epoll syscalls.
2. Memory-friendly. Much effort has been spent into making the garbage collection more predictable, since tail latency, e.g. unpredictable
long pauses in the JVM, is particularly bad in big datacenters. While Rust has more radical approach (i.e. avoiding garbage collection
entirely) Go retains more predictable performance, while not forcing developers to learn a new pardigm (see below). Furthermore
the availability of structs and tuples as value types, reduces the need to navigate chains of pointers making GC lighter.
3. Easy deployment and dependency management. Delivering a statically linked binary makes deployment easy and fast. This makes a difference 
when deploying to huge numbers of nodes. 
4. Fast compilation. Still an advantage with continuous deployment on a massive scale.
5. Readability and short learning curve. The language has been kept very simple, avoiding sources of complexity like generics, with the
specific aim of making onboarding of new programmers and transfer of code responsibility easier. This obviously has the drawback of denying
programmers the leverage of higher abstraction constructs, thus making programs potentially more verbose and boilerplate code unavoidable,
but clearly the goal of the language designer was removing the attrition of programmer's mobility in a huge organisation like Google, while
making long-term maintenability possible. Also, making the language very opinionated reduces the space of solution implementations, making 
easier to understand someone's code.

To summarise, use Go if:
- You write massively concurrent code
- Don't care too much about abstraction
- Can live with minor random latency due to GC (but more predictable than Java)
- Care about quick compilation
- Need to deploy to many nodes, can't manage dependency or runtime deployment

LS
